import pulp
import pandas as pd

def otimizar_transporte_capacidade_maxima(df_saldos, df_rotas):
    """
    Otimiza o transporte obrigando que as rotas selecionadas operem em capacidade máxima
    
    Parâmetros:
    df_saldos - DataFrame com colunas: praca, saldo
    df_rotas - DataFrame com colunas: origem, destino, empresa, quantidade_transportada, custo_transporte
    
    Retorna:
    DataFrame com as rotas selecionadas e suas quantidades (sempre na capacidade máxima)
    """
    
    # Criar identificador único para cada rota
    df_rotas = df_rotas.reset_index().rename(columns={'index': 'rota_id'})
    
    # Criar o problema de otimização
    prob = pulp.LpProblem("Transporte_com_Capacidade_Maxima", pulp.LpMinimize)
    
    # Conjuntos
    locais_positivos = df_saldos[df_saldos['saldo'] > 0]['praca'].tolist()
    locais_negativos = df_saldos[df_saldos['saldo'] < 0]['praca'].tolist()
    
    # Variáveis de decisão binárias - indica se a rota é utilizada ou não
    var_uso_rota = pulp.LpVariable.dicts(
        "Usar_Rota",
        df_rotas['rota_id'].tolist(),
        cat='Binary'
    )
    
    # Função objetivo: minimizar o custo total
    prob += pulp.lpSum(
        var_uso_rota[row['rota_id'] * row['quantidade_transportada'] * row['custo_transporte']
        for _, row in df_rotas.iterrows()
    )
    
    # Restrição 1: Não exceder saldo disponível nos locais de origem
    for local in locais_positivos:
        prob += pulp.lpSum(
            var_uso_rota[row['rota_id'] * row['quantidade_transportada']
            for _, row in df_rotas[df_rotas['origem'] == local].iterrows()
        ) <= df_saldos[df_saldos['praca'] == local]['saldo'].values[0]
    
    # Restrição 2: Atender toda a demanda dos locais com saldo negativo
    for local in locais_negativos:
        prob += pulp.lpSum(
            var_uso_rota[row['rota_id'] * row['quantidade_transportada']
            for _, row in df_rotas[df_rotas['destino'] == local].iterrows()
        ) >= -df_saldos[df_saldos['praca'] == local]['saldo'].values[0]
    
    # Resolver o problema
    prob.solve()
    
    # Processar resultados
    if pulp.LpStatus[prob.status] == 'Optimal':
        resultados = []
        for _, row in df_rotas.iterrows():
            if var_uso_rota[row['rota_id']].value() == 1:
                resultados.append({
                    'Origem': row['origem'],
                    'Destino': row['destino'],
                    'Empresa': row['empresa'],
                    'Rota_ID': row['rota_id'],
                    'Quantidade_Transportada': row['quantidade_transportada'],
                    'Custo_Unitario': row['custo_transporte'],
                    'Custo_Total': row['quantidade_transportada'] * row['custo_transporte']
                })
        
        df_resultados = pd.DataFrame(resultados)
        custo_total = df_resultados['Custo_Total'].sum()
        print(f"Solução ótima encontrada! Custo total: R${custo_total:.2f}")
        return df_resultados
    else:
        print("Não foi encontrada solução ótima.")
        print("Status:", pulp.LpStatus[prob.status])
        return None

# Exemplo de uso
if __name__ == "__main__":
    # Dados de exemplo
    data_saldos = {
        'praca': ['A', 'B', 'C', 'D', 'E'],
        'saldo': [100, 200, -80, -120, -100]
    }
    
    data_rotas = {
        'origem': ['A', 'A', 'A', 'B', 'B', 'B', 'B'],
        'destino': ['C', 'C', 'D', 'C', 'D', 'E', 'E'],
        'empresa': ['Trans1', 'Trans1', 'Trans1', 'Trans2', 'Trans2', 'Trans3', 'Trans3'],
        'quantidade_transportada': [40, 50, 60, 70, 80, 90, 100],
        'custo_transporte': [10, 9, 15, 12, 18, 20, 19]
    }
    
    df_saldos = pd.DataFrame(data_saldos)
    df_rotas = pd.DataFrame(data_rotas)
    
    # Executar a otimização
    resultado = otimizar_transporte_capacidade_maxima(df_saldos, df_rotas)
    
    if resultado is not None:
        print("\nRotas selecionadas:")
        print(resultado[['Origem', 'Destino', 'Empresa', 'Quantidade_Transportada', 'Custo_Total']])
