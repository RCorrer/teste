import pandas as pd
import itertools
import networkx as nx

def calcular_combinacoes_rotas_nx(origem, destino, quantidade, df_rotas, max_intermediarias=3, n_melhores=5):
    """
    Versão usando NetworkX para encontrar combinações de rotas.
    """
    # 1. Criar o grafo direcionado
    G = nx.DiGraph()
    
    # Adicionar arestas com atributos
    for _, row in df_rotas.iterrows():
        G.add_edge(row['ORIGEM'], row['DESTINO'], 
                   empresa=row['EMPRESA'],
                   valor=row['VALOR_TRANSPORTADO'],
                   custo=row['CUSTO'])
    
    # 2. Encontrar todos os caminhos simples com comprimento limitado
    try:
        caminhos = list(nx.all_simple_paths(G, source=origem, target=destino, 
                                          cutoff=max_intermediarias+1))
    except nx.NetworkXNoPath:
        return []
    
    # 3. Processar cada caminho
    combinacoes = []
    
    for caminho in caminhos:
        # Gerar todas as combinações de rotas possíveis para este caminho
        edges_in_path = list(zip(caminho[:-1], caminho[1:]))
        rotas_possiveis = []
        
        for u, v in edges_in_path:
            # Todas as rotas entre u e v
            rotas_uv = []
            for data in G.get_edge_data(u, v).values():
                rotas_uv.append({
                    'origem': u,
                    'destino': v,
                    'empresa': data['empresa'],
                    'valor': data['valor'],
                    'custo': data['custo']
                })
            rotas_possiveis.append(rotas_uv)
        
        # Gerar combinações de rotas para este caminho
        for combinacao_rotas in itertools.product(*rotas_possiveis):
            valor_min = min(rota['valor'] for rota in combinacao_rotas)
            if valor_min == 0:
                continue
                
            repeticoes = quantidade // valor_min
            if quantidade % valor_min != 0:
                repeticoes += 1
                
            custo_total = sum(rota['custo'] for rota in combinacao_rotas) * repeticoes
            valor_total = valor_min * repeticoes
            
            combinacoes.append({
                'caminho': caminho,
                'rotas': combinacao_rotas,
                'valor_transportado': valor_min,
                'repeticoes': repeticoes,
                'valor_total': valor_total,
                'custo_total': custo_total,
                'custo_por_unidade': custo_total / valor_total
            })
    
    # 4. Ordenar e selecionar as melhores
    combinacoes.sort(key=lambda x: x['custo_total'])
    return combinacoes[:n_melhores]

# Exemplo de uso
if __name__ == "__main__":
    # Dados de exemplo
    data_rotas = {
        'ORIGEM': ['A', 'A', 'B', 'B', 'B', 'F', 'G', 'X', 'X', 'A', 'C', 'D', 'C', 'A', 'E', 'F'],
        'DESTINO': ['C', 'D', 'D', 'E', 'C', 'E', 'F', 'C', 'E', 'F', 'E', 'E', 'F', 'B', 'G', 'G'],
        'EMPRESA': ['T1', 'T1', 'T2', 'T2', 'SAQUE BB', 'T3', 'T4', 'SAQUE BB', 'SAQUE BB', 'T5', 'T6', 'T7', 'T8', 'T9', 'T10', 'T11'],
        'VALOR_TRANSPORTADO': [50, 60, 70, 80, 90, 40, 30, 100, 120, 20, 30, 40, 50, 55, 60, 70],
        'CUSTO': [500, 600, 700, 800, 900, 400, 300, 1000, 1200, 200, 300, 400, 500, 550, 600, 700]
    }
    
    df_rotas = pd.DataFrame(data_rotas)
    
    origem = 'A'
    destino = 'G'
    quantidade = 200
    
    print("Calculando com NetworkX...")
    resultados_nx = calcular_combinacoes_rotas_nx(origem, destino, quantidade, df_rotas)
    
    for i, res in enumerate(resultados_nx, 1):
        print(f"\nCombinação #{i}")
        print(f"Caminho: {' → '.join(res['caminho'])}")
        print(f"Custo Total: R${res['custo_total']:,.2f}")
        print(f"Valor Transportado: {res['valor_total']}")
        print("Rotas:")
        for rota in res['rotas']:
            print(f"  {rota['origem']}→{rota['destino']} ({rota['empresa']}) - Valor: {rota['valor']} - Custo: R${rota['custo']}")
