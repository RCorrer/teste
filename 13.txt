import pandas as pd
import pulp as pl
from itertools import combinations

# Dados de exemplo (substitua pelos seus DataFrames reais)
df_saldo_capacita = pd.DataFrame({
    'PRACA': ['A', 'B', 'C', 'D', 'E', 'F'],
    'SALDO': [150, -40, 200, -30, -20, 100],
    'DATA': ['2023-01-01']*6
})

df_custos_capacita = pd.DataFrame({
    'ORIGEM': ['A', 'A', 'B', 'C', 'C', 'D', 'F', 'F'],
    'DESTINO': ['B', 'C', 'D', 'D', 'E', 'E', 'B', 'D'],
    'EMPRESA': ['T1', 'T1', 'T2', 'T1', 'T2', 'T1', 'T2', 'T1'],
    'VALOR_TRANSPORTADO': [0]*8,  # Será definido pelo modelo
    'CUSTO': [10, 15, 12, 8, 10, 5, 7, 9]
})

df_tx_saque = pd.DataFrame({
    'PRACA': ['A', 'B', 'C', 'D', 'E', 'F'],
    'TX_SAQUE': [0.02, 0.03, 0.025, 0.035, 0.04, 0.03]
})

# 1. Preparar os dados
pracas = df_saldo_capacita['PRACA'].unique()
pracas_negativas = df_saldo_capacita[df_saldo_capacita['SALDO'] < 0]['PRACA'].tolist()
pracas_positivas = df_saldo_capacita[df_saldo_capacita['SALDO'] > 0]['PRACA'].tolist()

saldo = df_saldo_capacita.set_index('PRACA')['SALDO'].to_dict()
tx_saque = df_tx_saque.set_index('PRACA')['TX_SAQUE'].to_dict()

# Criar lista de rotas de transporte
rotas = [(row['ORIGEM'], row['DESTINO']) for _, row in df_custos_capacita.iterrows()]
custos_transporte = {(row['ORIGEM'], row['DESTINO']): row['CUSTO'] for _, row in df_custos_capacita.iterrows()}

# 2. Função para encontrar as k melhores soluções
def encontrar_melhores_solucoes(praca_alvo, k=5):
    modelo = pl.LpProblem(f"Abastecimento_{praca_alvo}", pl.LpMinimize)
    
    # Variáveis de decisão
    x = pl.LpVariable.dicts("Transporte", rotas, lowBound=0, cat='Continuous')
    s = pl.LpVariable("Saque", lowBound=0, cat='Continuous')
    
    # Função objetivo
    modelo += pl.lpSum([x[r] * custos_transporte[r] for r in rotas]) + s * tx_saque[praca_alvo]
    
    # Restrições
    for p in pracas_positivas:
        modelo += pl.lpSum([x[r] for r in rotas if r[0] == p]) <= saldo[p]
    
    modelo += pl.lpSum([x[r] for r in rotas if r[1] == praca_alvo]) + s >= -saldo[praca_alvo]
    
    # Resolver e coletar soluções
    solucoes = []
    
    for i in range(k):
        modelo.solve()
        
        if modelo.status != pl.LpStatusOptimal:
            break
            
        # Coletar valores das variáveis
        transporte = {r: x[r].varValue for r in rotas if x[r].varValue > 0}
        saque = s.varValue
        
        # Adicionar solução
        solucoes.append({
            'custo_total': pl.value(modelo.objective),
            'saque': saque,
            'transportes': transporte,
            'rotas_utilizadas': [{'origem': r[0], 'destino': r[1], 
                                 'valor': x[r].varValue, 
                                 'custo': custos_transporte[r]} 
                                for r in rotas if x[r].varValue > 0]
        })
        
        # Adicionar restrição para evitar a mesma solução
        modelo += pl.lpSum([x[r] for r in transporte.keys()]) <= sum(transporte.values()) - 0.01
    
    return solucoes

# 3. Encontrar soluções para cada praça com saldo negativo
resultados_completos = {}
for praca in pracas_negativas:
    resultados_completos[praca] = encontrar_melhores_solucoes(praca)

# 4. Processar resultados em DataFrames
# DataFrame detalhado com todas as rotas
dados_detalhados = []
for praca, solucoes in resultados_completos.items():
    for idx, sol in enumerate(solucoes, 1):
        # Adicionar linhas para transportes
        for rota in sol['rotas_utilizadas']:
            dados_detalhados.append({
                'PRACA_ALVO': praca,
                'OPCAO_NUM': idx,
                'TIPO': 'TRANSPORTE',
                'ORIGEM': rota['origem'],
                'DESTINO': rota['destino'],
                'VALOR': rota['valor'],
                'CUSTO_UNITARIO': rota['custo'],
                'CUSTO_TOTAL': rota['valor'] * rota['custo'],
                'CUSTO_TOTAL_OPCAO': sol['custo_total']
            })
        
        # Adicionar linha para saque (mesmo que zero)
        dados_detalhados.append({
            'PRACA_ALVO': praca,
            'OPCAO_NUM': idx,
            'TIPO': 'SAQUE',
            'ORIGEM': None,
            'DESTINO': None,
            'VALOR': sol['saque'],
            'CUSTO_UNITARIO': tx_saque[praca],
            'CUSTO_TOTAL': sol['saque'] * tx_saque[praca],
            'CUSTO_TOTAL_OPCAO': sol['custo_total']
        })

df_detalhado = pd.DataFrame(dados_detalhados)

# DataFrame consolidado por opção
dados_consolidados = []
for praca, solucoes in resultados_completos.items():
    for idx, sol in enumerate(solucoes, 1):
        dados_consolidados.append({
            'PRACA_ALVO': praca,
            'OPCAO_NUM': idx,
            'MELHOR_OPCAO': idx == 1,
            'TOTAL_TRANSPORTADO': sum(r['valor'] for r in sol['rotas_utilizadas']),
            'CUSTO_TRANSPORTE': sum(r['valor'] * r['custo'] for r in sol['rotas_utilizadas']),
            'TOTAL_SACADO': sol['saque'],
            'CUSTO_SAQUE': sol['saque'] * tx_saque[praca],
            'CUSTO_TOTAL': sol['custo_total'],
            'ESTRATEGIA': 'Transporte' if sum(r['valor'] for r in sol['rotas_utilizadas']) > 0 and sol['saque'] == 0 
                          else 'Saque' if sum(r['valor'] for r in sol['rotas_utilizadas']) == 0 and sol['saque'] > 0
                          else 'Mista'
        })

df_consolidado = pd.DataFrame(dados_consolidados)

# 5. Exibir resultados
print("=== Melhores opções por praça ===")
for praca in pracas_negativas:
    print(f"\nPraça: {praca} (Déficit: {-saldo[praca]})")
    df_praca = df_consolidado[df_consolidado['PRACA_ALVO'] == praca]
    print(df_praca[['OPCAO_NUM', 'ESTRATEGIA', 'TOTAL_TRANSPORTADO', 'TOTAL_SACADO', 'CUSTO_TOTAL']])

# 6. Retornar DataFrames organizados
resultados = {
    'detalhes_rotas': df_detalhado,
    'opcoes_consolidadas': df_consolidado,
    'melhores_opcoes': df_consolidado[df_consolidado['MELHOR_OPCAO']]
}

resultados
